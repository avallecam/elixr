---
title: "mixtools"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# VIGNETTE

```{r}
library(mixtools)
data("faithful")
faithful
#help(faithful)
```

```{r}
hist(faithful$waiting)
```

## EM algorith

```{r}
wait1 <- mixtools::normalmixEM(faithful$waiting,lambda = .5,mu = c(55,80),sigma = .5)

plot(wait1,density = TRUE#,
     #cex.axis=1.4, cex.lab=1.4, cex.main=1.8,
     #main2="Time between Old Faithful eruptions", xlab2="Minutes"
     )
```

```{r}
class(wait1)
summary(wait1)
```

### cutoff

```{r}
library(mixtools)

simulate <- function(lambda=0.3, mu=c(0, 4), sd=c(1, 1), n.obs=10^5) {
    x1 <- rnorm(n.obs, mu[1], sd[1])
    x2 <- rnorm(n.obs, mu[2], sd[2])    
    return(ifelse(runif(n.obs) < lambda, x1, x2))
}

x <- simulate()

model <- normalmixEM(x=x, k=2)
index.lower <- which.min(model$mu)  # Index of component with lower mean

find.cutoff <- function(proba=0.5, i=index.lower) {
    ## Cutoff such that Pr[drawn from bad component] == proba
    f <- function(x) {
        proba - (model$lambda[i]*dnorm(x, model$mu[i], model$sigma[i]) /
                     (model$lambda[1]*dnorm(x, model$mu[1], model$sigma[1]) + model$lambda[2]*dnorm(x, model$mu[2], model$sigma[2])))
        }
        return(uniroot(f=f, lower=-10, upper=10)$root)  # Careful with division by zero if changing lower and upper
}

cutoffs <- c(find.cutoff(proba=0.5), find.cutoff(proba=0.75))  # Around c(1.8, 1.5)

hist(x)
abline(v=cutoffs, col=c("red", "blue"), lty=2)
```

```{r}
x <- faithful$waiting

model <- normalmixEM(x=x, k=2)
index.lower <- which.min(model$mu)  # Index of component with lower mean

find.cutoff <- function(proba=0.5, i=index.lower) {
    ## Cutoff such that Pr[drawn from bad component] == proba
    f <- function(x) {
        proba - (model$lambda[i]*dnorm(x, model$mu[i], model$sigma[i]) /
                     (model$lambda[1]*dnorm(x, model$mu[1], model$sigma[1]) + model$lambda[2]*dnorm(x, model$mu[2], model$sigma[2])))
        }
        return(uniroot(f=f, 
                       lower=as.numeric(quantile(x,0.05)), 
                       upper=as.numeric(quantile(x,0.95))
                       )$root)  # Careful with division by zero if changing lower and upper
}

cutoffs <- c(find.cutoff(proba=0.1), find.cutoff(proba=0.9))  # Around c(1.8, 1.5)

#hist(x)
plot(model,density = TRUE)
abline(v=cutoffs, col=c("red", "blue"), lty=2)
```


## cutpoint methods

```{r}
#help("Waterdata")

data("Waterdata")

Waterdata
```

```{r}
cutpts <- 10.5*(-6:6)
watermult <- makemultdata(Waterdata,cuts = cutpts)
```

### estimate multinomial parameters via EM algorith

```{r}
set.seed(15)
theta4 <- matrix(runif(56),ncol = 14)
theta3 <- theta4[1:3,]
mult3 <- multmixEM(watermult,
                   lambda = rep(1/3,3),theta = theta3)
mult4 <- multmixEM(watermult,
                   lambda = rep(1/4,4),theta = theta4)
```

```{r,fig.height=4,fig.width=8}
par(mfrow=c(1,2))
compCDF(Waterdata,
        mult3$posterior,
        lwd=2,
        #lab=c(7,5,7),
        xlab="Angle in degrees",
        ylab="Component CDF",
        main="Three-Component Solution")
compCDF(Waterdata,
        mult4$posterior,
        lwd=2,
        #lab=c(7,5,7),
        xlab="Angle in degrees",
        ylab="Component CDF",
        main="Four-Component Solution")
```

```{r}
summary(mult3)
summary(mult4)
```

# BLOG TUTORIAL

```{r}
theme_set(theme_bw())
```


## exploratory

```{r,fig.height=3,fig.width=4}
library("ggplot2")
library("dplyr")

faithful %>% as.tibble()

options(scipen = 999)

p <- ggplot(faithful, aes(x = waiting)) +
  geom_density()
p
```

```{r,fig.height=3,fig.width=4}
p + 
  geom_vline(xintercept = 53, col = "red", size = 2) + 
  geom_vline(xintercept = 80, col = "blue", size = 2)
```

## using GMM

- Gaussian Mixture Model

```{r,fig.height=3,fig.width=4}
library("mixtools")

#' Plot a Mixture Component
#' 
#' @param x Input data
#' @param mu Mean of component
#' @param sigma Standard deviation of component
#' @param lam Mixture weight of component

plot_mix_comps <- function(x, mu, sigma, lam) {
  lam * dnorm(x, mu, sigma)
}

set.seed(1)
wait <- faithful$waiting
mixmdl <- normalmixEM(wait, k = 2)
```

```{r,fig.height=3,fig.width=4}
tibble(x = mixmdl$x) %>%
  ggplot() +
  geom_histogram(aes(x, ..density..), 
                 binwidth = 1, 
                 colour = "black", 
                 fill = "gray"
                 ) +
  stat_function(geom = "line", 
                fun = plot_mix_comps,
                args = list(mixmdl$mu[1], 
                            mixmdl$sigma[1], 
                            lam = mixmdl$lambda[1]),
                colour = "red", lwd = 1.5) +
  stat_function(geom = "line", 
                fun = plot_mix_comps,
                args = list(mixmdl$mu[2], 
                            mixmdl$sigma[2], 
                            lam = mixmdl$lambda[2]),
                colour = "blue", lwd = 1.5) +
  ylab("Density")
```

## check estimated parameters

```{r}
# means per gaussian ditribution
mixmdl$mu
# standard deviation of each mean per gaussian ditribution
mixmdl$sigma
# area under the curve (density) per gaussian ditribution
# or mixing weights/proportions/coefficients
mixmdl$lambda
```

## posterior probability of belonging to each component

```{r}
post.df <- as.data.frame(cbind(x = mixmdl$x, mixmdl$posterior))
head(post.df, 10)  # Retrieve first 10 rows
```

```{r}
# inbetween infered components
post.df %>%
  filter(x > 66, x < 68)
```

## soft labeling: user choose threshold

```{r,fig.height=3,fig.width=4}
post.df %>%
  #define observations as threshold = 0.95 (95% probability of belonging to a component)
  mutate(label = ifelse(comp.1 > 0.95, 1, 
                        ifelse(comp.2 > 0.95, 2, 0))) %>% 
  ggplot(aes(x = factor(label))) +
  geom_bar() +
  xlab("Component") +
  ylab("Number of Data Points")
```

## cutoff

```{r}
x <- faithful$waiting

model <- normalmixEM(x=x, k=2)
index.lower <- which.min(model$mu)  # Index of component with lower mean

find.cutoff <- function(proba=0.5, i=index.lower) {
    ## Cutoff such that Pr[drawn from bad component] == proba
    f <- function(x) {
        proba - (model$lambda[i]*dnorm(x, model$mu[i], model$sigma[i]) /
                     (model$lambda[1]*dnorm(x, model$mu[1], model$sigma[1]) + model$lambda[2]*dnorm(x, model$mu[2], model$sigma[2])))
        }
        return(uniroot(f=f, 
                       lower=as.numeric(quantile(x,0.05)), 
                       upper=as.numeric(quantile(x,0.95))
                       )$root)  # Careful with division by zero if changing lower and upper
}

cutoffs <- c(find.cutoff(proba=0.1), find.cutoff(proba=0.9))  # Around c(1.8, 1.5)

cutoffs
```


```{r,fig.height=3,fig.width=4}
post.df %>% 
  ggplot() +
  geom_line(aes(x,comp.1), colour="red", lwd = 1.5) +
  geom_line(aes(x,comp.2), colour="blue", lwd = 1.5) +
  geom_hline(yintercept = .9, col = "black") +
  geom_vline(xintercept = cutoffs[2] #63.6
             , col = "black", lty=3) +
  geom_vline(xintercept = cutoffs[1] #69.7
             , col = "black", lty=3) +
  ylab("classification probability")
```

