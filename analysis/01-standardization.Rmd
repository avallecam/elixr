---
title: "from Template to Standardized ELISA"
author: "Andree Valle Campos"
date: '`r Sys.Date()`'
output: 
  html_document:
#  pdf_document:
#  html_notebook:
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: yes
    code_folding: "hide"
#    number_sections: TRUE
#    df_print: kable
#    fig_caption: true
#  documentclass: report
bibliography: SeroMarker.bib
csl: american-medical-association.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, # CHANGE TO FALSE IN PDF_DOCUMENTS
                      warning = FALSE) 
knitr::opts_knit$set(root.dir = '../.') #gsub("/analysis","",getwd())
#getwd()
options(width = 110) # CHANGE TO DEFAULT in PDF
# FOR PDF CHANGE: html_document, toc_float, number_sections, echo, width
# FOR PDF add new page USE: four \newpage BEFORE #SETUP #APPENDIX #COMPUTER.env #REFERENCES
```

# Setup 

This report is writen in **R** [@R] within a `Rmarkdown` [@rmarkdown] notebook using the `RStudio` [@rstudio] IDE software, and employing the `knitr` [@knitr] and `Hmisc` [@Hmisc] packages for the `html` setup.

This dynamic document integrates **text**, **code** and **results**. For more information, I recommend a recent 2016 review in spanish about **Reproducible science: what, why, how?** [@CienciaReproducible2016].

```{r setup0, results='hide', message=FALSE, eval=TRUE}
require(Hmisc)
#require(plotly)
#options(#grType='plotly',  # for certain graphics functions
#        width = 110) # to expand the limits of CONSOLE output
mu <- markupSpecs$html   # markupSpecs is in Hmisc

# The following hidden command (<code>r mu$widescreen()</code>), causes the html notebook to use an entire wide screen.
#mu$widescreen()
```
`r mu$widescreen()`

# Summary

**OBJECTIVE:**

* Principal: 
    - Standardize the OD~450nm~ values across ELISA plates by the estimation of the Antibody Units of each unknown sample.

* Secondary:
    - Implement a [reproducible workflow](https://www.ncbi.nlm.nih.gov/pubmed/26776185) for standardization of ELISA plates from a template matrix.

**SOLVED PROBLEMS:**


# Introduction

This is an R implementation of a pipeline for the standardization of ELISA plates directly from a template matrix.


# Dependencies

The required R packages for this analysis are:

+ XLConnect [@XLConnect]
+ drc [@Ritz2015]

```{r, results='hide', message=FALSE}
##essential
library(XLConnect) # to load EXCEL files
library(drc)       # Dose-Response modeling
##accesory
library("DiagrammeR") # method Flowchart
#library("rcompanion") # pseudo R-2
library("knitr")     # To display nice tables
##extra
library("ggplot2")
library("Rmisc")        #multiploting ggplots
```

# Method

```{r, fig.align='center', fig.width=9}
#install.packages("DiagrammeR")
#library(DiagrammeR)

DiagrammeR("
  graph LR
    A[XLS data] -.-> |XLConnect| B{R data}
    B --> C1[STD]
    B --> E[ctr +/-]
    B --> D1[UNK]
    
    C1 -.-> |drc| C2[4pLL model]
    C2 --> C3[Box-Cox]
    C3 --> F{UNK Ab.units}

    D1 --> D2[mean.OD]
    D2 --> D3[OD %CV]
    D3 --> F
    
    F --> G1[Histogram]
    F --> G2[Density]
    F --> G3[QQPlot]

    style A fill:#ffffff, stroke:#000000, stroke-width:2px
    style B fill:#ffffff, stroke:#000000, stroke-width:2px
    style C1 fill:#ffffff, stroke:#000000, stroke-width:2px
    style C2 fill:#ffffff, stroke:#000000, stroke-width:2px
    style C3 fill:#ffffff, stroke:#000000, stroke-width:2px
    style D1 fill:#ffffff, stroke:#000000, stroke-width:2px
    style D2 fill:#ffffff, stroke:#000000, stroke-width:2px
    style D3 fill:#ffffff, stroke:#000000, stroke-width:2px
    style E fill:#ffffff, stroke:#000000, stroke-width:2px
    style F fill:#ffffff, stroke:#000000, stroke-width:2px
    style G1 fill:#ffffff, stroke:#000000, stroke-width:2px
    style G2 fill:#ffffff, stroke:#000000, stroke-width:2px
    style G3 fill:#ffffff, stroke:#000000, stroke-width:2px
")
```

## Log-Logistic (4pLL) model

The curve of the **log-logistic symetric** model describe the *response* `f(x)` dependent of the *dose* `x` and **04 parameters**: $$ f(x)=f(x;b,c,d,e)=c+\frac{d-c}{1+\exp[b(log(x)-log(e))]}\ $$ where: 
  
- `c` is the **lower limit** of the response when the *dose* `x` approaches infinity, 
- `d` is the **upper limit** when the *dose* `x` approaches zero,
- `b` is the **slope** around the **point of inflection**, represented by 
- `e` defined as **effective dose** and commmonly denoted as [@Ritz2015]:
    + `ED50`, `EC50` or `IC50` for continuous responses,
    + `LD50` or `LC50` for binomial responses, and
    + $T_{50}$ for event-time responses.

# Procedure

**12 summary plots** per ELISA Template:

- **3x3 plots** of STD and UNK distribution, residual variance distribution, and model transformation.
- **1x3 plots** of OD~450nm~, mean.OD and Ab.units distributions by Density plots.


```{r}
#
## CREATE A LIST WITH THE FILE.NAMES
#
a <- "Template_ELISA_N"
b <- seq(11,41,1)
b <- b[-c(3,4,9)] # NO TEMPLATE AVAILABLE
c <- ".xlsx"
#
d <- paste0(a,b,c)
#d[j]
data.frame(d)
#
e <- rep("data-raw/",length(d))
#e <- rep("~/Documents/Valle_GnB/000_R_script_MIRRORS/R_test/SeroMarkerMir/data-raw/",length(d))
d <- paste0(e,d)
```

```{r}
## A NULL DATA.FRAME TO FEED WITH DATA.ANALYSIS OUTCOMES
wb11_Ab <- data.frame()
paramALL <- data.frame()
```

```{r, fig.align='center', fig.height=12, fig.width=9}
#
## A LOOP TO ANALYSE EACH TEMPLATE
#
for (j in 1:length(d)) {
#
####
#### START ANALYSIS
####
# 1 UPLOAD excel data
wb11 <- loadWorkbook(d[j])
#
wb11_Pf_main <- readWorksheet(wb11, 
                         sheet = 1, 
                         startRow = 22, endRow = 30,
                         startCol = 3, endCol = 14)
wb11_Pf <- readWorksheet(wb11, 
                         sheet = 1, 
                         startRow = 33, endRow = 41,
                         startCol = 3, endCol = 14)
wb11_Pv_main <- readWorksheet(wb11, 
                         sheet = 1, 
                         startRow = 79, endRow = 87,
                         startCol = 3, endCol = 14)
wb11_Pv <- readWorksheet(wb11, 
                         sheet = 1, 
                         startRow = 90, endRow = 98,
                         startCol = 3, endCol = 14)
# 2 GENERATE R DATA.FRAME
Pf.OD <- matrix(wb11_Pf[1,])
Pf.ID <- matrix(wb11_Pf_main[1,])
Pv.OD <- matrix(wb11_Pv[1,])
Pv.ID <- matrix(wb11_Pv_main[1,])

for (i in 2:nrow(wb11_Pf)) {
  Pf.OD <- rbind(Pf.OD,matrix(wb11_Pf[i,]))
  Pf.ID <- rbind(Pf.ID,matrix(wb11_Pf_main[i,]))
  Pv.OD <- rbind(Pv.OD,matrix(wb11_Pv[i,]))
  Pv.ID <- rbind(Pv.ID,matrix(wb11_Pv_main[i,]))
}
#
t<-seq(1,12,1)
x <- c()
x0 <- 50
f <- function(x){x*2}
x[1]<-x0
for (i in 1:(length(t)-1)) {
  x[i+1] = f(x[i])
}
#

wb11_ALL <- data.frame(paste0("N",b[j]),
                      rbind(Pf.ID,Pv.ID),
                      rbind(matrix(rep("std",12)),
                            matrix(rep("unk",80)),"std",
                            matrix(rep("ctr",2)),"std"), 
                      rep(x[length(x)]/x), ##FACTOR for AB.UNITS
                      rbind(Pf.OD,Pv.OD), 
                      gl(2,96, labels = c("Pfal","Pviv")))
colnames(wb11_ALL) <- c("Plate", "ID", "Type", "Ab.unit", "OD", "Specie")
wb11_ALL$ID <- unlist(wb11_ALL$ID)
wb11_ALL$OD <- unlist(wb11_ALL$OD)
wb11_ALL$ID <- factor(wb11_ALL$ID)
# 2.1 AVOID NA's
wb11_ALL <- wb11_ALL[complete.cases(wb11_ALL[,2]),]
# 2.2 CLEAN data.frame
wb11_ALL[wb11_ALL$Type!="std","Ab.unit"] <- NA
wb11_ALL[wb11_ALL$ID=="Blank","Ab.unit"] <- 0
# 2.3 CORRECT variable class
wb11_ALL$OD <- as.numeric(wb11_ALL$OD)
#
# 2.4 IDENTIFY blank ctrl+ ctrl-
blank.Pfal <- mean(as.numeric(wb11_ALL[wb11_ALL$ID=="Blank" & wb11_ALL$Specie=="Pfal",5]))
blank.Pviv <- mean(as.numeric(wb11_ALL[wb11_ALL$ID=="Blank" & wb11_ALL$Specie=="Pviv",5]))
ctrPos.Pfal <- mean(as.numeric(wb11_ALL[wb11_ALL$ID=="C+" & wb11_ALL$Specie=="Pfal",5]))
ctrPos.Pviv <- mean(as.numeric(wb11_ALL[wb11_ALL$ID=="C+" & wb11_ALL$Specie=="Pviv",5]))
ctrNeg.Pfal <- mean(as.numeric(wb11_ALL[wb11_ALL$ID=="C-" & wb11_ALL$Specie=="Pfal",5]))
ctrNeg.Pviv <- mean(as.numeric(wb11_ALL[wb11_ALL$ID=="C-" & wb11_ALL$Specie=="Pviv",5]))
# 3 UNK MEAN OD
wb11_UNK <- subset(wb11_ALL, Type=="unk")
wb11_UNK$ID <- factor(wb11_UNK$ID) # unk goes from 
n <- length(levels(wb11_UNK$ID))
# 3.1 MEAN DATA.FRAME
wb11_MEAN <- data.frame(paste0("N",b[j]),
                        levels(wb11_UNK$ID),
                        rep("unk",length(levels(wb11_UNK$ID))), 
                        rep(NA,length(levels(wb11_UNK$ID))),#Ab.unit
                        rep(NA,length(levels(wb11_UNK$ID))),#mean.OD
                        gl(2,length(levels(wb11_UNK$ID)), 
                           labels = c("Pfal","Pviv")))
colnames(wb11_MEAN) <- c("Plate", "ID", "Type", "Ab.unit", "mean.OD", "Specie")
# 3.2 FEED MEAN DATA.FRAME
for (i in 1:n) {
  wb11_MEAN[i,5] <- mean(as.numeric(subset(wb11_UNK, 
                                           ID==levels(wb11_UNK$ID)[i] &
                                             Specie==levels(wb11_UNK$Specie)[1])$OD))
  wb11_MEAN[n+i,5] <- mean(as.numeric(subset(wb11_UNK, 
                                             ID==levels(wb11_UNK$ID)[i] &
                                               Specie==levels(wb11_UNK$Specie)[2])$OD))
}
#
######
###### [OFF] BACKGROUND SUBTRACTION
######
# 4 STD.DEV DATA.FRAME
wb11_SDCV <- cbind(wb11_MEAN, 
                   rep(NA,length(levels(wb11_UNK$ID))),#mean.OD
                   rep(NA,length(levels(wb11_UNK$ID))))#sd.OD)
colnames(wb11_SDCV) <- c("Plate", "ID", "Type", "Ab.unit", "mean.OD", "Specie", "sd.OD", "cv.OD")
# 4.1 FEED STD.DEV DATA.FRAME
for (i in 1:n) {
  wb11_SDCV[i,7] <- sd(subset(wb11_UNK, 
                              ID==levels(wb11_UNK$ID)[i] &
                                Specie==levels(wb11_UNK$Specie)[1])$OD)
  wb11_SDCV[n+i,7] <- sd(subset(wb11_UNK, 
                                ID==levels(wb11_UNK$ID)[i] &
                                  Specie==levels(wb11_UNK$Specie)[2])$OD)
}

wb11_SDCV[,8] <- 100*(wb11_SDCV[,7] / wb11_SDCV[,5])
#
# 5 PARAMETER ESTIMATION 4pLL model
#
wb11.m1 <- drm(OD ~ Ab.unit, Specie, 
               data= subset(wb11_ALL, Type=="std"),
               fct = LL.4(names = c("b", "c", "d", "e")))
#
wb11.model <- wb11.m1
# 6 BOX-COX TRANSFORMATION against RESIDUAL heterogeneity
wb11.model.BX <- boxcox(wb11.model, 
                     main=expression("Optimal " ~ lambda ~ " with confidence intervals"), 
                     plotit = FALSE)
# 7 UNK AB.UNITS ESTIMATION by INVERSE REGRESSION
wb11_Resp.Pf <- ED(wb11.model.BX, 
                   wb11_MEAN[1:n,5],
                   type = "absolute",interval = "delta",
                   clevel = "Pfal", display = FALSE)
wb11_Resp.Pv <- ED(wb11.model.BX, 
                   wb11_MEAN[(n+1):(2*n),5],
                   type = "absolute",interval = "delta",
                   clevel = "Pviv", display = FALSE)
# 7.1 FEED UNK AB.UNITS DATA.FRAME
for (i in 1:n) {
  wb11_SDCV[i,4] <- wb11_Resp.Pf[i]
  wb11_SDCV[n+i,4] <- wb11_Resp.Pv[i]
}
#
####
#### END ANALYSIS
#
#### START PLOTTING
####
#
par(mfrow=c(4,3))
### 1 DISTRIBUTION PLOTING
plot(OD ~ log(Ab.unit), 
     data=subset(wb11_ALL, Type=="std" & Specie=="Pfal"), 
     ylim = c(0,1.5), col="red",
     xlab = "log(Ab unit)", ylab = "OD 450nm",
     main= paste0("ELISA plate"," ","N",b[j],"\n Standard samples distribution"))
points(OD ~ log(Ab.unit), 
       data=subset(wb11_ALL, Type=="std" & Specie=="Pviv"), 
       pch=2, col="blue")
abline(h=c(ctrNeg.Pfal, ctrNeg.Pviv), lty=c(3, 3), col=c("red", "blue"))
abline(h=c(ctrPos.Pfal, ctrPos.Pviv), lty=c(3, 3), col=c("red", "blue"))
abline(h=c(blank.Pfal, blank.Pviv), lty=c(2, 2), col=c("red", "blue"))
legend("bottomright", c("P.vivax","P.falcip", "C+/-", "blank"), 
       col = c( "blue", "red", "black", "black"), 
       pch = c(2, 1, NA, NA), #lwd= c(1,1),
       lty = c(NA, NA, 3, 2),
       cex = 0.8,
       inset = .01#, merge = TRUE
)
#
### 2 %CV CONDITIONAL PLOTING
plot(cv.OD ~ mean.OD,wb11_SDCV, 
     ylim=c(0,100), xlim=c(0,1.5),
     xlab="mean OD 450nm of duplicates",
     ylab="%CV of duplicates",
     main="Percentage Coefficient of Variation")
abline(h=20, v=0.25, lty=2, col=2)
#
### 3 UNK AB.UNITS PLOTING
plot(wb11.model.BX,#broken = TRUE,
     ylim = c(0,1.5), 
     xlim = c(0,5e3),
     main=paste0("ELISA plate"," ","N",b[j],"\n Unknown samples distribution"),
     col="grey",
     legendPos = c(2,1.5))
points(y=wb11_MEAN[(n+1):(2*n),5],x=wb11_Resp.Pv[1:n],col="blue",pch=4)
points(y=wb11_MEAN[1:n,5],x=wb11_Resp.Pf[1:n],col="red",pch=4)
#abline(h=c(ctrNeg.Pfal, ctrNeg.Pviv), lty=c(3, 3), col=c("red", "blue"))
#abline(h=c(ctrPos.Pfal, ctrPos.Pviv), lty=c(3, 3), col=c("red", "blue"))
#abline(h=c(blank.Pfal, blank.Pviv), lty=c(2, 2), col=c("red", "blue"))
legend("bottomright", c("P.vivax","P.falcip"), #, "C+/-", "blank"
       col = c( "blue", "red"), #, "black", "black"
       pch = c(4, 4), #, NA, NA #lwd= c(1,1),
       #lty = c(NA, NA), #, 3, 2
       cex = 0.8,
       inset = .01#, merge = TRUE
)
#
### 4 VARIANCE HETEROGENEITY
plot(residuals(wb11.model) ~ fitted(wb11.model), 
     main="4p Log-Logistic model \n Variance Hetereogeneity",
     xlab="fitted",
     ylab = "residuals")
abline(h=0)
#
### 5 LAMBDA ESTIMATE ##------Box-Cox transformation-------##
wb11.model.BX <- boxcox(wb11.model, 
                     main=expression("Optimal " ~ lambda ~ " with confidence intervals"))
#
### 6 VARIANCE HOMOGENEITY
plot(residuals(wb11.model.BX) ~ fitted(wb11.model.BX), 
     main="Box-Cox transformed model \n Variance Homogeneity",
     xlab="fitted",
     ylab = "residuals")
abline(h=0)
#
### 7 RESIDUAL SKWENESS
qqnorm(residuals(wb11.model), 
       main = "4p Log-Logistic model \n Normal Q-Q Plot")
qqline(residuals(wb11.model))
#
### 8 DRC AND BOXCOX OVERLAPPED MODELS
plot(wb11.model, #broken = TRUE, 
     xlab="Ab units", ylab="OD 450nm",
     ylim = c(0,1.5), 
     xlim = c(0,5e3),
     main="in black: 4p Log-Logistic model \n in red: Box-Cox transformed model",
     legendPos = c(2,1.5))
plot(wb11.model.BX, col = "red", add = TRUE, legend = FALSE,
     ylim = c(0,1.5), 
     xlim = c(0,5e5))
#
### 9 RESIDUAL NORMALITY
qqnorm(residuals(wb11.model.BX), 
       main="Box-Cox transformed model \n Normal Q-Q Plot")
qqline(residuals(wb11.model.BX))
#
####
####
#
### 10 OD REPLICATES DISTRIBUTION
#par(mfrow=c(3,3))
#my <- max(hist(wb11_ALL$OD, plot = F)$counts, na.rm=TRUE)
#hist(wb11_ALL$OD, ylim = c(0,my), 
#     main= paste0("ELISA plate"," ","N",b[j]),
#     xlab = "OD")
plot(density(na.omit(wb11_ALL$OD)),
     main = "OD Density plot",
     xlab = "OD")#, ylim = c(0,my)  #, xlim = c(0,mx)
#qqnorm(wb11_ALL$OD); qqline(wb11_ALL$OD)
#
### 11 OD MEAN DISTRIBUTION
#hist(wb11_MEAN$mean.OD, ylim = c(0,my),
#     main = "mean.OD Histogram",
#     xlab = "mean.OD")
plot(density(na.omit(wb11_MEAN$mean.OD)),
     main = "mean.OD Density plot",
     xlab = "mean.OD")#, ylim = c(0,my)
#qqnorm(wb11_MEAN$mean.OD); qqline(wb11_MEAN$mean.OD)
#
### 12 AB.UNIT DISTRIBUTION
#hist(wb11_SDCV$Ab.unit, ylim = c(0,my),
#     main = "Ab.units Histogram",
#     xlab = "Ab.units")
plot(density(na.omit(wb11_SDCV$Ab.unit)),
     main = "Ab.units Density plot",
     xlab = "Ab.units")#, ylim = c(0,my)
#qqnorm(wb11_SDCV$Ab.unit); qqline(wb11_SDCV$Ab.unit)
#
####
#### END PLOTTING
#### START ROW BINDING TO FINAL DATA.FRAME
####
wb11_Ab <- rbind(wb11_Ab,wb11_SDCV)
####
paramALL <- rbind(paramALL, t(data.frame(coefficients(wb11.model.BX)[3:6])))
####
}

```

# save .Rds
```{r}
saveRDS(wb11_Ab, "data/01-output-raw.rds")
saveRDS(paramALL, "data/01-parameters.rds")
saveRDS(Pf.ID, "data/01-dilutions.rds")
```


***

# Computer environment

```{r}
sessionInfo()
```


# References
